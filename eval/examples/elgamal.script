//! El-Gamal encryption on a prime-order cyclic group.

dbg(GEN, ORDER);

PublicKey = impl(#{
    encrypt: |self, message| {
        r = rand_scalar();
        shared_secret = self.0 ^ r;
        #{ R: GEN ^ r, B: message * shared_secret }
    },
});

SecretKey = impl(#{
    decrypt: |self, { R, B }| {
        shared_secret = R ^ self.0;
        B / shared_secret
    },
    public_key: |self| PublicKey((GEN ^ self.0,)),
});

gen = || {
    sk = SecretKey((rand_scalar(),));
    #{ sk, pk: sk.public_key() }
};

// Test!
{ sk, pk } = gen();

while(5, |i| i != 0, |i| {
    message = GEN ^ rand_scalar();
    dbg(message);
    encrypted = pk.encrypt(message);
    dbg(encrypted);
    assert_eq(sk.decrypt(encrypted), message);

    i - 1
});

// Advanced testing making use of partial homomorphicity of encryption.
ONE = GEN ^ 0;
encrypt_and_combine = |pk, messages| {
    messages.map(|msg| pk.encrypt(msg)).fold(
        #{ R: ONE, B: ONE },
        |enc_x, enc_y| enc_x * enc_y,
    )
};

messages = (1, 2, 3, 4, 5).map(|_| GEN ^ rand_scalar());
assert_eq(
    sk.decrypt(encrypt_and_combine(pk, messages)),
    messages.fold(ONE, |acc, msg| acc * msg)
);
