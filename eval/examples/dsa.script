//! DSA signatures on a prime-order cyclic group.

dbg(GEN, ORDER);

PublicKey = impl(#{
    verify: |self, message, { r, s }| {
        (u1, u2) = (hash_to_scalar(message) / s, r / s);
        to_scalar(GEN ^ u1 * self.0 ^ u2) == r
    },
});

SecretKey = impl(#{
    sign: |self, message| {
        k = rand_scalar();
        r = to_scalar(GEN ^ k);
        s = (hash_to_scalar(message) + self.0 * r) / k;
        #{ r, s }
    },
    public_key: |self| PublicKey((GEN ^ self.0,)),
});

gen = || {
    sk = SecretKey((rand_scalar(),));
    #{ sk, pk: sk.public_key() }
};

// Test!
{ sk, pk } = gen();
{ pk: other_pk } = gen();

while(5, |i| i != 0, |i| {
    message = rand_scalar();
    dbg(message);
    signature = sk.sign(message);
    dbg(signature);

    assert(pk.verify(message, signature));
    assert(!other_pk.verify(message, signature));
    assert(!pk.verify(rand_scalar(), signature));

    i - 1
});
