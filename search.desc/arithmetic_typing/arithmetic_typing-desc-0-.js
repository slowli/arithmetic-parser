searchState.loadedDescShard("arithmetic_typing", 0, "Hindley–Milner type inference for arithmetic expressions …\nGrammar with support of type annotations. Works as a …\nAny type aka “I’ll think about typing later”. …\nBoolean primitive type.\nArbitrary type implementing certain constraints. Similar …\nArbitrary type implementing certain constraints. Similar …\nLength that can vary at runtime, similar to lengths of …\n0-based index from the end of the tuple.\nFunction together with constraints on type variables …\nFunctional type.\nFunctional type.\nBuilder for functional types.\nLength variable.\nMiddle element.\nNumeric primitive type.\nObject type: a collection of named fields with …\nObject type.\nPrimitive type.\nPrimitive types in a certain type system.\nSlice type. Unlike in Rust, slices are a subset of tuples. …\n0-based index from the start of the tuple.\nTuple type.\nTuple type.\nIndex of an element within a tuple.\nGeneric tuple length.\nEnumeration encompassing all types supported by the type …\nEnvironment containing type information on named variables.\nType variable.\nUnknown / variable length, e.g., of a tuple.\nLength variable.\nType variable.\nGets the argument types of this function.\nTypes allowing to customize various aspects of the type …\nReturns this tuple as slice if it fits (has no start or …\nASTs for type annotations and their parsing logic.\nReturns a builder for <code>Function</code>s.\nReturns components of this length.\nReturns mutable references to the components of this …\nType definitions for the standard types from the …\nReturns the element type of this slice.\nIterates over all distinct elements in this tuple. The …\nErrors related to type inference.\nIterates over field names in this object.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGets type of the specified variable.\nReturns type of a field with the specified <code>name</code>.\nReturns the 0-based index of this variable.\nReturns the 0-based index of this variable.\nSets type of a variable.\nAdds the specified <code>constraint</code> to these constraints.\nInserts a <code>Constraint</code> into the environment so that it can …\nInserts an <code>ObjectSafeConstraint</code> into the environment so …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts this object into a corresponding dynamic …\nReturns <code>true</code> iff this type does not contain type / length …\nReturns <code>true</code> iff this type does not contain type / length …\nReturns <code>true</code> iff this tuple is guaranteed to be empty.\nReturns <code>true</code> iff this slice is definitely empty.\nChecks if this constraint set is empty.\nIs this variable free (not bounded in a function …\nIs this variable free (not bounded in a function …\nChecks if this type is void (i.e., an empty tuple).\nIterates over variables contained in this env.\nIterates over fields in this object.\nCreates constraints based on a single constraint.\nReturns the length of this tuple.\nReturns the length of this slice.\nCreates an empty environment.\nCreates an empty object.\nCreates a new complex tuple.\nCreates a new slice.\nReturns the enclosed object constraint, if any.\nCreates a bounded length variable that can be used to …\nCreates a bounded type variable that can be used to build …\nCreates a bounded type variable that can be used to build …\nCreates a bounded type variable with the specified <code>index</code>.\nReturns shared references to the parts comprising this …\nReturns exclusive references to the parts comprising this …\nProcesses statements with the default type arithmetic. …\nProcesses statements with a given <code>arithmetic</code>. After …\nCreates a slice type by repeating this type.\nGets the return type of this function.\nDeclares the return type of the function and builds it.\nCreates a slice type.\nVisitor traits allowing to traverse <code>Type</code> and related types.\nReturns a void type (an empty tuple).\nReturns well-known constraints for this type. These …\nAdds a new argument to the function definition.\nMarks type params with the specified <code>indexes</code> to have …\nMarks type params with the specified <code>indexes</code> to have …\nMarks lengths with the specified <code>indexes</code> as static.\nMarks lengths with the specified <code>indexes</code> as static.\nAdds or sets varargs in the function definition.\nBoolean type.\nCode spans related to a binary operation.\nBoolean value (true or false).\nSimplest <code>TypeArithmetic</code> implementation that defines unary …\nConstraint that can be placed on <code>Type</code>s.\nSet of <code>Constraint</code>s.\nPrimitive type which supports a notion of <em>linearity</em>. …\n<code>Constraint</code> for numeric types that can be subject to unary <code>-</code>…\nMaps a literal value from a certain <code>Grammar</code> to its type. …\nPrimitive types for the numeric arithmetic: <code>Num</code>eric type …\nNumeric type (e.g., 1).\nArithmetic on <code>Num</code>bers.\nMarker trait for object-safe constraints, i.e., …\nSettings for constraints placed on arguments of binary …\n<code>Constraint</code> for numeric types that can participate in …\nTypes of literals output by this mapper.\nHelper to define <em>structural</em> <code>Constraint</code>s, i.e., constraints …\nSet of equations and constraints on type variables.\nArithmetic allowing to customize primitive types and how …\nCode spans related to a unary operation.\n<code>PrimitiveType</code> that has Boolean type as one of its variants.\nMarks <code>len</code> as static, i.e., not containing …\nOperation argument.\nClones this constraint into a <code>Box</code>.\nMarks that dynamically sized slices should fail the …\nResolves the type by following established equality links …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInserts a constraint into this set.\nInserts <code>constraints</code> for a type var with the specified …\nInserts an object-safe constraint into this set.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChecks if this constraint set is empty.\nReturns <code>true</code> iff this type is linear.\nCreates a set with one constraint.\nSpanned left-hand side.\nConstraint applied to the argument of <code>T op Num</code> / <code>Num op T</code> …\nCreates a new helper. <code>predicate</code> determines whether a …\nCreates an empty set.\nCreates and returns a new type variable.\nUnary operation.\nBinary operation.\nConstraint applied to the arguments of in-kind binary …\nHandles a binary operation.\nProcesses a binary operation.\nProcesses a binary operation according to the numeric …\nHandles a unary operation.\nProcesses a unary operation.\nProcesses a unary operation according to the numeric …\nReturns a visitor that resolves the type using equality …\nSpanned right-hand side.\nGets the type of the provided literal value.\nUnifies types in <code>lhs</code> and <code>rhs</code>.\nApplies binary ops logic to unify the given LHS and RHS …\nReturns a <code>Visit</code>or that will be applied to constrained <code>Type</code>…\nReturns a <code>Visit</code>or that can be used for …\nCreates an instance of arithmetic that supports order …\nCreates an instance of arithmetic that does not support …\nAny type (<code>any</code>).\nKinds of errors that can occur when converting <code>*Ast</code> types …\nParameter constraints, e.g. <code>for&lt;len! N; T: Lin&gt;</code>.\nField with the same name is defined multiple times in an …\nDynamically applied constraints (<code>dyn _</code>).\nDynamic tuple length. This length is <em>implicit</em>, as in <code>[Num]</code>…\nEmbedded param quantifiers.\nLength param not scoped by a function.\nType param not scoped by a function.\nFunctional type.\nParsed functional type.\nFunctional type with constraints.\nNon-ticked identifier, e.g., <code>Bool</code>.\nReference to a length; for example, <code>N</code> in <code>[Num; N]</code>.\nSome length (<code>_</code>) encountered when parsing a standalone type.\nSome type (<code>_</code>) encountered when parsing a standalone type.\nConstraint is not object-safe.\nObject type; for example, <code>{ len: Num }</code>. Not to be confused …\nObject type or constraint, such as …\nTicked identifier, e.g., <code>&#39;T</code>.\nSlice type; for example, <code>[Num]</code> or <code>[(Num, T); N]</code>.\nParsed slice type, such as <code>[Num; N]</code>.\nType placeholder (<code>_</code>). Corresponds to a certain type that …\nLength placeholder (<code>_</code>). Corresponds to any single length.\nSpanned <code>TypeAst</code>.\nTuple type; for example, <code>(Num, Bool)</code>.\nParsed tuple type, such as <code>(Num, Bool)</code> or …\nParsed tuple length.\nType annotation after parsing.\nBounds that can be placed on a type variable.\nUnknown constraint.\nUnknown type name.\nUnused length param.\nUnused length param.\nFunction arguments.\nElement of this slice; for example, <code>Num</code> in <code>[Num; N]</code>.\nElements at the end of the tuple, e.g., <code>Bool</code> in …\nExtra information that can be embedded by the user.\nFields of the object.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLength of this slice; for example, <code>N</code> in <code>[Num; N]</code>.\nMiddle of the tuple, e.g., <code>[T; _]</code> in <code>(Num, Bool, ...[T; _])</code>…\nObject constraint, such as <code>{ x: &#39;T }</code>.\nParses <code>input</code> as a type. This parser can be composed using …\nParses <code>input</code> as a functional type. This parser can be …\nReturn type of the function.\nElements at the beginning of the tuple, e.g., <code>Num</code> and <code>Bool</code> …\nStatic lengths, e.g., <code>N</code> in <code>for&lt;len! N&gt;</code>.\nSpans corresponding to constraints, e.g. <code>Foo</code> and <code>Bar</code> in …\nTries to convert this type into a <code>Function</code>.\nParses type AST from a string.\nType constraints.\nConstraints on function params.\nFunction body.\nType of the <code>all</code> function.\nType of the <code>any</code> function.\nType of the <code>assert</code> function.\nType of the <code>assert_eq</code> function.\nType of the <code>assert_fails</code> function.\nDefinitions for <code>assert</code> and <code>assert_eq</code> functions.\nType of the <code>defer</code> function.\n<code>false</code> type (Boolean).\nType of the <code>filter</code> function.\nType of the <code>fold</code> function.\nType of the <code>if</code> function.\nType of the <code>map</code> function.\nType of the <code>merge</code> function.\nMap containing type definitions for all variables from …\nType of the <code>push</code> function.\n<code>true</code> type (Boolean).\nType of the <code>while</code> function.\nReturns the type of the <code>array</code> generation function from the …\nReturns the type of the <code>assert_close</code> function from the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns an iterator over all type definitions in the …\nReturns an iterator over all type definitions in <code>Assertions</code>…\nAssignment.\nError while instantiating a type from AST.\nBinary operation.\nCannot access fields in a value (i.e., it’s not an …\nValue cannot be indexed (i.e., not a tuple).\nLength with the static constraint is actually dynamic …\nType error together with the corresponding code span.\nContext of a <code>Error</code> corresponding to a top-level operation …\nKinds of errors that can occur during type inference.\nFragment of a path for an <code>Error</code>.\nList of <code>Error</code>s.\nFailure when applying constraint to a type.\nField set differs between LHS and RHS, which are both …\nFunction argument with the specified index (0-based; can …\nThe tuple represents function arguments.\nFunction call.\nFunction definition.\nFunction return type.\nGeneric tuple use: assignment, destructuring, or creating …\nIndex is out of bounds for the indexed tuple.\nField name is invalid.\nLeft-hand side of a binary operation.\nProcessing lvalue (before assignment).\nConcrete object does not have required fields.\nNo context.\nObject field with the specified name.\nField access for an object.\nError container tied to a particular top-level operation …\nTrying to unify a type with a type containing it.\nRepeated assignment to the same variable in function args …\nRepeated field in object initialization / destructuring.\nRight-hand side of a binary operation.\nContext in which a tuple is used.\nTuple element with the specified index (0-based; can be …\nTuple indexing operation.\nIncompatible tuple lengths.\nType cast.\nTrying to unify incompatible types. The first type is LHS, …\nUnary operation.\nUndefined variable occurrence.\nMention of a bounded type or length variable in a type …\nLanguage feature not supported by type inference logic.\nUnsupported indexing operation. For example, the receiver …\nUnsupported use of type or length params in a function …\nType not supported by type inference logic. For example, a …\nMutably borrows this container allowing to use it multiple …\nInvokes the provided closure and returns <code>false</code> if new …\nGets the context for an operation that has failed.\nCreates a “failed constraint” error.\nReturns the index of the first failing statement within a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChecks if this list is empty (there are no errors).\nIterates over errors contained in this list.\nNarrows down the path to the error.\nGets the kind of this error.\nReturns the number of errors in this list.\nGets the most specific code span of this error.\nGets the path of this error relative to the failed …\nAdds a new <code>error</code> into this the error list.\nGets the root code location of the failed operation. May …\nCreates an error for an lvalue type not supported by the …\nTypes of function arguments.\nSignature of the call.\nFunction definition. Note that this is not necessarily a …\nLeft-hand side of the assignment.\nRight-hand side of the assignment.\nSource type of the casted value.\nTarget type of the cast.\nType being indexed.\nType being accessed.\nAvailable object fields.\nFailing constraint.\nContext in which the error has occurred.\nMissing fields.\nIndex.\nActual tuple length.\nLength of the LHS. This is the length determined by type …\nFields in LHS.\nLength of the RHS. This is usually the actual tuple length …\nFields in RHS.\nType that fails constraint requirement.\nRecursive traversal across the shared reference to a <code>Type</code>.\nRecursive traversal across the exclusive reference to a …\nVisits a <code>Type::Dyn</code> variant.\nVisits a <code>Type::Dyn</code> variant.\nDefault implementation of <code>Visit::visit_function()</code>.\nVisits a functional type.\nDefault implementation of <code>VisitMut::visit_function_mut()</code>.\nVisits a functional type.\nVisits a middle length of a tuple.\nDefault implementation of <code>Visit::visit_object()</code>.\nVisits an object type.\nDefault implementation of <code>VisitMut::visit_object_mut()</code>.\nVisits an object type.\nVisits a primitive type.\nDefault implementation of <code>Visit::visit_tuple()</code>.\nVisits a tuple type.\nDefault implementation of <code>VisitMut::visit_tuple_mut()</code>.\nVisits a tuple type.\nDefault implementation of <code>Visit::visit_type()</code>.\nVisits a generic type.\nDefault implementation of <code>VisitMut::visit_type_mut()</code>.\nVisits a generic type.\nVisits a type variable.")