//! Schnorr signatures on a prime-order cyclic group.

dbg(GEN, ORDER);

PublicKey = impl(#{
    verify: |self, message, { e, s }| {
        R = GEN ^ s * self.pk ^ e;
        e == hash_to_scalar(R, message)
    },
});

SecretKey = impl(#{
    sign: |self, message| {
        r = rand_scalar();
        R = GEN ^ r;
        e = hash_to_scalar(R, message);
        #{ e, s: r - self.sk * e }
    },
    public_key: |self| PublicKey(#{ pk: GEN ^ self.sk }),
});

gen = || {
    sk = SecretKey(#{ sk: rand_scalar() });
    #{ sk, pk: sk.public_key() }
};

// Test!
{ sk, pk } = gen();
{ pk: other_pk } = gen();

while(5, |i| i != 0, |i| {
    message = rand_scalar();
    dbg(message);
    signature = sk.sign(message);
    dbg(signature);

    assert(pk.verify(message, signature));
    assert(!other_pk.verify(message, signature));
    assert(!pk.verify(rand_scalar(), signature));

    i - 1
});
